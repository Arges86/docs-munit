= Storage Event Processors
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

The Storage processors allows you to manage temporary storage during  your tests.

All storage is cleared as soon as the test ends.

== Store operation

Stores the given data associated with the given key. If `value` not set, it defaults to the `payload`.

[source,xml,linenums]
----
<munit-tools:store key="myKey">
    <munit-tools:value>#[person : { name: 'John', lastName: 'Smith' }]</munit-tools:value>
</munit-tools:store>
----

== Retrieve operation

Retrieves the data associated with the given key

[source,xml,linenums]
----
<munit-tools:retrieve key="myKey"/>
----

== Remove operation

Removes and returns the data associated with the given key

[source,xml,linenums]
----
<munit-tools:remove key="myKey"/>
----

== Clear stored data operation

Clears all stored data

[source,xml,linenums]
----
<munit-tools:clear-stored-data/>
----

== Testing OAuth enabled connectors

Mule supports authorization through various OAuth grant types, including Authorization Code. That grant type is designed to allow an external system (your Mule app) to operate on behalf a user, without the need to share the user's credentials.

This is therefore challenging from a testing perspective. Because the Authorization Code Grant type is designed to force the intervention of a human in what's commonly known as "The OAuth dance", how to build an automated test that can be run several times a day and stil use this type of authentication?

For that we created a component that allows you to bypass the whole OAuth dance phase by manually providing a valid access token. It will be your responsability to manually obtain (and eventually update) such token.

Letâ€™s see it in action:

[source,xml,linenums]
----
<os:config name="TokenObjectStore_Config" />

<os:object-store name="tokenStore" persistent="true" config-ref="TokenObjectStore_Config" />

<sfdc:config name="sfdcConfig" ...>
	<sfdc:oauth-connection ....>
		<sfdc:oauth-authorization-code ... />
<sfdc:oauth-callback-config ... />
<sfdc:oauth-store-config objectStore="tokenStore" />
	</sfdc:oauth-connection>
</sfdc:config>
----

Above is a simple configuration of the Salesforce connector, using OAuth authentication, using a user defined object store to hold the tokens.

Next, we define the following flow:

[source,xml,linenums]
----
<flow name="storeOAuthToken">
   <munit-tools:store-oauth-token resourceOwnerId="testUser"
                                  ownerConfigName="sfdcConfig"
                                  accessToken="${accessToken}"
                                  refreshToken="${refreshToken}"
                                  expiresIn="${expiresIn}"
                                  state="${state}"
                                  overwrite="true"
                                  objectStore="tokenStore">
       <munit-tools:additional-parameters>#[{param1: 'foo', param2: 3}]</munit-tools:additional-parameters>
   </munit-tools:store-oauth-token>
</flow>
----

That flow will insert an access token into the store. Notice how the ownerConfigName matches the name of the Salesforce config.

Also notice how the access token and other properties are placeholders. The idea is that you manually obtain a token, by manually performing the OAuth dance. Then you supply the tokens to the test via system properties, properties file, or whatever mechanism you see fit. 

Then you run your Munit test which should look something like this:

[source,xml,linenums]
----
<munit:test name="oauthTest">
    <munit:behavior>
	<flow-ref name="storeOAuthToken" />
    </munit:behavior>
    <munit:execution>
            <sfdc:upsert config-ref="sfdcConfig" resourceOwnerId="testUser" ... />
    </munit:execution>
    <munit:validation>
            .... Your assertions here ....
    </munit:validation>
</munit:test>
----

Notice how:

* Inserting the token is the very first step in the test
* The `<sfdc:upsert>` operation references the same config name and resourceOwnerId that match that of the token we inserted.

=== Caveats

That token will eventually expire. How often will that happen depends on the service provider you're connecting to. When that happens, it will be up to you to obtain a new token and update the test with.
